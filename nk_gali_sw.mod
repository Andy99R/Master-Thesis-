//=====================================================================
//  NK Gali DSGE – sticky wages & prices  (α = 0)
//  Master Version for Iterative Mode Finding (Iteration 1)
//  Incorporates All Supervisor Feedback — [Current Date]
//=====================================================================

//==============================================================================
// Data Description and Preprocessing Summary (Assumed)
//==============================================================================
//   - y_obs    : Output gap (log real GDP, HP-filtered, cyclical component only, NOT additionally demeaned)
//   - pinf_obs : Price inflation (quarterly decimal rate, demeaned)
//   - w_obs    : Nominal wage inflation (quarterly decimal rate, demeaned)
//   - r_obs    : Nominal interest rate (quarterly decimal rate, demeaned)
//   - Data from 'eu_data.mat' generated by corrected Python script.
//==============================================================================

//---------------------------------------------------------------------
// 0) Endogenous & observable variables (log‑linear deviations)
//---------------------------------------------------------------------
var  y pif piw i wgap rn           // core model
     a up uw v                    // state variables / shocks
     y_obs w_obs r_obs pinf_obs;  // observables (aliases)

//---------------------------------------------------------------------
// 1) Exogenous shocks
//---------------------------------------------------------------------
varexo e_a   // technology shock (TFP)
       e_up  // price‑markup shock
       e_uw  // wage‑markup shock
       e_mp; // monetary‑policy shock

//---------------------------------------------------------------------
// 2) Parameters
//---------------------------------------------------------------------
parameters   beta                  // discount factor (fixed)
             sigma phi             // preference & labour supply (est.)
             phi_p phi_w phi_y     // Taylor‑rule coeffs (ALL est.)
             theta_p theta_w       // Calvo stickiness (est.)
             epsilon_p epsilon_w   // substitution elasticities (fixed)
             rho_a rho_up rho_uw   // AR(1) persistence for structural shocks (est.)
             rho_mp;               // MP‑shock persistence (est.)
            // psi_a removed as it will be a #variable

// --- Calibrated values ------------------------------------------------
beta      = 0.99;
epsilon_p = 6.0;    // elasticity of substitution between goods
epsilon_w = 6.0;    // elasticity of substitution between labor types

//---------------------------------------------------------------------
// 3) Model equations
//---------------------------------------------------------------------
model(linear); // Using model(linear) as equations are already log-linearized

  // (a) Technology process (AR1)
  a = rho_a*a(-1) + e_a;

  // (b) Derived psi_a_derived based on Gali (2008, Ch.3, p.56 for alpha=0)
  // rn_t = sigma * E_t{Delta y_n_{t+1}} where y_n_t = ( (1+phi) / (sigma+phi) ) * a_t
  // With a_t being a stationary AR(1) deviation, E_t{a(+1)} = rho_a*a.
  // Thus rn_t (as a deviation) = sigma * ( (1+phi) / (sigma+phi) ) * (rho_a*a - a)
  // which simplifies to sigma * ( (1+phi) / (sigma+phi) ) * (rho_a - 1) * a
  # psi_a_derived = sigma * ( (1+phi) / (sigma+phi) ) * (rho_a - 1);

  // Natural real rate of interest - depends on the level of 'a' (technology deviation)
  rn = psi_a_derived * a;

  // (c) Mark‑up shock processes (AR1)
  up = rho_up*up(-1) + e_up; // Price markup shock process
  uw = rho_uw*uw(-1) + e_uw; // Wage markup shock process

  // (d) Phillips‑curve coefficients
  # lambdap = (1-theta_p)*(1-beta*theta_p)/theta_p;
  # kappap  = 0; // Since alpha = 0
  # lambdaw = (1-theta_w)*(1-beta*theta_w)/(theta_w*(1+epsilon_w*phi));
  # kappaw  = lambdaw*(sigma + phi);

  // (1) Price Phillips curve
  pif = beta*pif(+1) + kappap*y + lambdap*wgap + up;

  // (2) Wage Phillips curve
  piw = beta*piw(+1) + kappaw*y - lambdaw*wgap + uw;

  // (3) Real‑wage gap accumulation (Gali Ch.6, Eq.18, corrected)
  // wgap_t = wgap_{t-1} + piw_t - pif_t - Delta_natural_real_wage_t
  // If natural real wage (log-dev) omega_n_t = a_t, then Delta_natural_real_wage_t = a - a(-1).
  wgap = wgap(-1) + piw - pif - (a - a(-1));

  // (4) Dynamic IS curve
  y = y(+1) - (1/sigma)*( i - pif(+1) - rn );

  // (5) Monetary policy rule with exogenous disturbance
  v = rho_mp*v(-1) + e_mp; // Monetary policy shock process (AR1)
  i = phi_p*pif + phi_w*piw + phi_y*y + v; // phi_w is now estimated

  // --- Measurement (identity) equations ---
  y_obs    = y;
  w_obs    = piw;
  r_obs    = i;
  pinf_obs = pif;
end;

//---------------------------------------------------------------------
// 4) Observables declaration
//---------------------------------------------------------------------
varobs y_obs w_obs r_obs pinf_obs;

//---------------------------------------------------------------------
// 5) Priors & estimated parameters
// Syntax: param_name, initial_value, lower_bound, upper_bound, prior_shape, prior_mean, prior_std_dev;
//---------------------------------------------------------------------
estimated_params;
  // — Shock standard deviations (Inverse‑Gamma) —
  // Prior std dev for these set to 0.25 for more diffuseness. Mean 0.10.
  stderr e_a,  0.10, 0.001, 5,  inv_gamma_pdf, 0.10, 0.25;
  stderr e_up, 0.10, 0.001, 5,  inv_gamma_pdf, 0.10, 0.25;
  stderr e_uw, 0.10, 0.001, 5,  inv_gamma_pdf, 0.10, 0.25;
  stderr e_mp, 0.10, 0.001, 5,  inv_gamma_pdf, 0.10, 0.25;

  // — Persistence parameters (Beta distribution) —
  rho_a,  0.85, 0.10, 0.99, beta_pdf, 0.85, 0.10;
  rho_up, 0.70, 0.10, 0.99, beta_pdf, 0.70, 0.10;
  rho_uw, 0.70, 0.10, 0.99, beta_pdf, 0.70, 0.10;
  rho_mp, 0.50, 0.10, 0.99, beta_pdf, 0.50, 0.10;

  // — Calvo stickiness parameters (Beta distribution) —
  // Priors centered at 0.75, std dev 0.10 to encourage conventional stickiness.
  theta_p, 0.75, 0.05, 0.98, beta_pdf, 0.75, 0.10;
  theta_w, 0.75, 0.05, 0.98, beta_pdf, 0.75, 0.10;

  // — Structural preference & policy parameters (Gamma distribution) —
  sigma,  2.00, 0.50, 5.0,  gamma_pdf, 2.00, 0.50;
  phi,    2.00, 0.25, 5.0,  gamma_pdf, 2.00, 0.50;
  phi_p,  1.50, 1.01, 4.0,  gamma_pdf, 1.50, 0.20; // Lower Bound 1.01 for Taylor Principle
  phi_y,  0.25, 0.05, 2.0,  gamma_pdf, 0.25, 0.10;
  phi_w,  0.50, 0.05, 2.0,  gamma_pdf, 0.50, 0.25; // Estimating phi_w
end;

//---------------------------------------------------------------------
// 6) Initial values for optimization
//---------------------------------------------------------------------
estimated_params_init;
  stderr e_a,  0.10; stderr e_up, 0.10; stderr e_uw, 0.10; stderr e_mp, 0.10;
  rho_a,  0.85; rho_up, 0.70; rho_uw, 0.70; rho_mp, 0.50;
  theta_p, 0.75; theta_w, 0.75;
  sigma,   2.00; phi,     2.00;
  phi_p,   1.50; // Start at prior mean, satisfies LB > 1.01
  phi_y,   0.25; phi_w,   0.50;
end;

//---------------------------------------------------------------------
// 7) Identification diagnostics
//---------------------------------------------------------------------
identification;

//---------------------------------------------------------------------
// 8) Bayesian estimation - CONFIGURED FOR ITERATIVE MODE FINDING (Iteration 1)
//---------------------------------------------------------------------
estimation(
  datafile     = 'eu_data.mat',
  first_obs    = 2,
  nobs         = 190, // <<< NUMBER OF OBSERVATIONS FOR ESTIMATION (e.g., up to 2017Q4)
                     // This value needs to be set correctly based on your data.
  mode_compute = 6, // Or 0 if you have a good mode_file from iterative finding
  // mode_file    = 'path_to_your_best_mode.mat', // Optional, if you have it
  mh_replic    = 500000, // Or desired number
  mh_nblocks   = 5,
  mh_drop      = 0.5,
  // mh_jscale not specified
  bayesian_irf,
  smoother,
  nograph, // Suppress graphs during MCMC
  // To combine forecast directly in Dynare 6+:
  forecast = 8 // Number of periods to forecast ahead (e.g., 8 quarters)
               // You can also specify variables here: forecast(periods=8) y_obs pinf_obs;
) y pif piw i wgap; // Variables for estimation output


//---------------------------------------------------------------------
// 9) Post-estimation: Compute and store state‑space matrices
//    Comment out for iterative mode finding. Uncomment for final MCMC run
//    or if you want to extract matrices based on an intermediate mode.
//---------------------------------------------------------------------
stoch_simul(order = 1, irf = 0, nograph);
//=====================================================================
// END OF FILE
//=====================================================================